<!DOCTYPE html>
<html>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <title>The source code</title>
  <link href="../resources/prettify/prettify.css" type="text/css" rel="stylesheet" />
  <script type="text/javascript" src="../resources/prettify/prettify.js"></script>
  <style type="text/css">
    .highlight { display: block; background-color: #ddd; }
  </style>
  <script type="text/javascript">
    function highlight() {
      document.getElementById(location.hash.replace(/#/, "")).className = "highlight";
    }
  </script>
</head>
<body onload="prettyPrint(); highlight();">
  <pre class="prettyprint lang-js"><span id='Echo-Control'>/**
</span> * @class Echo.Control
 * Foundation class implementing core logic to create controls and manipulate with them.
 */
Echo.Control = function() {};

// static interface

<span id='Echo-Control-static-method-create'>/**
</span> * @static
 * @method
 * Function which creates a control object using it manifest declaration.
 *
 * @param {Object} manifest
 * Specifies the control interface in the predefined way.
 *
 * @param {String} manifest.name
 * Specifies the control name including namespace (ex. &quot;Echo.StreamServer.Controls.Submit&quot;)
 *
 * @param {Object} [manifest.vars]
 * Specifies internal control variables.
 *
 * @param {Object} [manifest.config]
 * Specifies the configuration data with the ability to define default values.
 *
 * @param {Object} [manifest.labels]
 * Specifies the list of language labels used in the particular control UI.
 *
 * @param {Object} [manifest.events]
 * Specifies the list of external events used by control.
 *
 * @param {Object} [manifest.methods]
 * Specifies the list of control methods.
 *
 * @param {Object} [manifest.renderers]
 * Specifies the list of control renderers.
 *
 * @param {Object} [manifest.templates]
 * Specifies the list of control templates.
 *
 * @param {Function} [manifest.init]
 * Function called during control initialization.
 *
 * @param {String} [manifest.css]
 * Specifies the CSS rules for the control.
 *
 * @return {Object}
 * Reference to the generated control class.
 */
Echo.Control.create = function(manifest) {
	var control = Echo.Utils.getNestedValue(window, manifest.name);

	// prevent multiple re-definitions
	if (control) return control;

	var constructor = function(config) {
		var self = this;

		// perform basic validation of incoming params
		if (!config || !config.target || !config.appkey) return {};

		this.data = config.data || {};
		this.name = manifest.name;
		this.config = config;
		this._init(this._initializers.get(&quot;init&quot;));
	};

	Echo.Utils.inherit(constructor, manifest.inherits || Echo.Control);

	var prototype = constructor.prototype;
	constructor.manifest = manifest;
	if (manifest.methods) {
		$.extend(prototype, manifest.methods);
	}
	if (manifest.templates) {
		prototype.templates = $.extend({}, prototype.templates, manifest.templates);
	}

	// define CSS class and prefix for the class
	prototype.cssClass = manifest.name.toLowerCase().replace(/-/g, &quot;&quot;).replace(/\./g, &quot;-&quot;);
	prototype.cssPrefix = prototype.cssClass + &quot;-&quot;;

	Echo.Utils.setNestedValue(window, manifest.name, constructor);
	return constructor;
};

<span id='Echo-Control-static-method-manifest'>/**
</span> * @static
 * Method returning common manifest structure.
 *
 * @param {String} name
 * Specifies control name.
 *
 * @return {Object}
 * Basic control manifest declaration.
 */
Echo.Control.manifest = function(name) {
	return {
		&quot;name&quot;: name,
		&quot;vars&quot;: {},
		&quot;config&quot;: {},
		&quot;labels&quot;: {},
		&quot;events&quot;: {},
		&quot;methods&quot;: {},
		&quot;renderers&quot;: {},
		&quot;templates&quot;: {},
		&quot;dependencies&quot;: [],
		&quot;init&quot;: function() {
			this.dom.render();
			this.ready();
		},
		&quot;destroy&quot;: undefined
	};
};

<span id='Echo-Control-static-method-addInitializer'>/**
</span> * @static
 * Method which adds new initializer scheme to the control (or control extender) prototype. Initializer function must be defined.
 *
 * @param {Object} klass
 * Specifies control (Echo.Control or extender) object.
 *
 * @param {Array} schema
 * Initializer schema which declare name and executed step.
 *
 * @param {Object} rule
 * Object containing action as key and target as value. Target is a defined initializer name. If this parameter is omitted then initializer will be pushed to the end of the list. Possible actions are:
 * + &quot;after&quot;
 * + &quot;before&quot;
 */
Echo.Control.addInitializer = function(klass, schema, rule) {
	rule = rule || {};
	var list = klass.prototype._initializers.list.slice(0);
	var hasRule = !!(rule.after || rule.before);
	var getInitializerIndex = function(name) {
		var index = -1;
		$.each(list, function(i, initializer) {
			if (initializer[0] === name) {
				index = i;
				return false;
			}
		});
		return index;
	};
	var index = hasRule
		? function(_index) {
			return ~_index
				? (!_index &amp;&amp; rule.before ? 0 : rule.after ? ++_index : --_index)
				: _index;
		}(getInitializerIndex(rule.after || rule.before))
		: list.length;
	list.splice(index, 0, schema);
	klass.prototype._initializers = $.extend({}, klass.prototype._initializers);
	klass.prototype._initializers.list = list;
};

Echo.Control.prototype.templates = {&quot;message&quot;: {}};

Echo.Control.prototype.templates.message.compact =
	'&lt;span class=&quot;echo-control-message echo-control-message-icon echo-control-message-{data:type} {class:messageIcon} {class:messageText}&quot; title=&quot;{data:message}&quot;&gt;&lt;/span&gt;';

Echo.Control.prototype.templates.message.full =
	'&lt;div class=&quot;echo-control-message {class:messageText}&quot;&gt;' +
		'&lt;span class=&quot;echo-control-message-icon echo-control-message-{data:type} {class:messageIcon}&quot;&gt;' +
			'{data:message}' +
		'&lt;/span&gt;' +
	'&lt;/div&gt;';

Echo.Control.prototype.defaults = {};

Echo.Control.prototype.defaults.vars = {
	&quot;cache&quot;: {},
	&quot;plugins&quot;: {},
	&quot;subscriptionIDs&quot;: {}
};

Echo.Control.prototype.defaults.config = {
<span id='Echo-Control-cfg-target'>	/**
</span>	 * @cfg {String} target(required)
	 * Specifies the DOM element where the control will be displayed.
	 */
	&quot;target&quot;: undefined,
<span id='Echo-Control-cfg-appkey'>	/**
</span>	 * @cfg {String} appkey (required)
	 * Specifies the customer application key. You can use the &quot;test.echoenabled.com&quot; appkey for testing purposes.
	 */
	&quot;appkey&quot;: &quot;&quot;,
<span id='Echo-Control-cfg-labels'>	/**
</span>	 * @cfg {Object} labels
	 * Specifies the set of language variables defined for this particular control.
	 */
	&quot;labels&quot;: {},
<span id='Echo-Control-cfg-apiBaseURL'>	/**
</span>	 * @cfg {String} [apiBaseURL=&quot;api.echoenabled.com/v1/&quot;]
	 * URL prefix for all API requests
	 */
	&quot;apiBaseURL&quot;: &quot;api.echoenabled.com/v1/&quot;,
<span id='Echo-Control-cfg-submissionProxyURL'>	/**
</span>	 * @cfg {String} [submissionProxyURL=&quot;apps.echoenabled.com/v2/esp/activity/&quot;]
	 * URL prefix for requests to Echo Submission Proxy
	 */
	&quot;submissionProxyURL&quot;: &quot;apps.echoenabled.com/v2/esp/activity/&quot;,
<span id='Echo-Control-cfg-infoMessages'>	/**
</span>	 * @cfg {Object} [infoMessages]
	 * Customizes the look and feel of info messages, for example &quot;loading&quot; and &quot;error&quot;.
	 *
	 * @cfg {Boolean} [infoMessages.enabled=true]
	 * Specifies if info messages should be rendered.
	 *
	 * @cfg {String} [infoMessages.layout=&quot;full&quot;]
 	 * Specifies the layout of the info message. By default can be set to &quot;compact&quot; or &quot;full&quot;.
	 *
	 *     &quot;infoMessages&quot; : {
	 *         &quot;enabled&quot; : true,
	 *         &quot;layout&quot; : &quot;full&quot;
	 *     }
	 */
	&quot;infoMessages&quot;: {
		&quot;enabled&quot;: true,
		&quot;layout&quot;: &quot;full&quot;
	},
	&quot;scriptLoadErrorTimeout&quot;: 5000, // 5 sec
	&quot;query&quot;: &quot;&quot;
};

Echo.Control.prototype.defaults.labels = {
<span id='Echo-Control-property-loading'>	/**
</span>	 * @echo_label
	 */
	&quot;loading&quot;: &quot;Loading...&quot;,
<span id='Echo-Control-property-retrying'>	/**
</span>	 * @echo_label
	 */
	&quot;retrying&quot;: &quot;Retrying...&quot;,
<span id='Echo-Control-property-error_busy'>	/**
</span>	 * @echo_label
	 */
	&quot;error_busy&quot;: &quot;Loading. Please wait...&quot;,
<span id='Echo-Control-property-error_timeout'>	/**
</span>	 * @echo_label
	 */
	&quot;error_timeout&quot;: &quot;Loading. Please wait...&quot;,
<span id='Echo-Control-property-error_waiting'>	/**
</span>	 * @echo_label
	 */
	&quot;error_waiting&quot;: &quot;Loading. Please wait...&quot;,
<span id='Echo-Control-property-error_view_limit'>	/**
</span>	 * @echo_label
	 */
	&quot;error_view_limit&quot;: &quot;View creation rate limit has been exceeded. Retrying in {seconds} seconds...&quot;,
<span id='Echo-Control-property-error_view_update_capacity_exceeded'>	/**
</span>	 * @echo_label
	 */
	&quot;error_view_update_capacity_exceeded&quot;: &quot;This stream is momentarily unavailable due to unusually high activity. Retrying in {seconds} seconds...&quot;,
<span id='Echo-Control-property-error_result_too_large'>	/**
</span>	 * @echo_label
	 */
	&quot;error_result_too_large&quot;: &quot;(result_too_large) The search result is too large.&quot;,
<span id='Echo-Control-property-error_wrong_query'>	/**
</span>	 * @echo_label
	 */
	&quot;error_wrong_query&quot;: &quot;(wrong_query) Incorrect or missing query parameter.&quot;,
<span id='Echo-Control-property-error_incorrect_appkey'>	/**
</span>	 * @echo_label
	 */
	&quot;error_incorrect_appkey&quot;: &quot;(incorrect_appkey) Incorrect or missing appkey.&quot;,
<span id='Echo-Control-property-error_internal_error'>	/**
</span>	 * @echo_label
	 */
	&quot;error_internal_error&quot;: &quot;(internal_error) Unknown server error.&quot;,
<span id='Echo-Control-property-error_quota_exceeded'>	/**
</span>	 * @echo_label
	 */
	&quot;error_quota_exceeded&quot;: &quot;(quota_exceeded) Required more quota than is available.&quot;,
<span id='Echo-Control-property-error_incorrect_user_id'>	/**
</span>	 * @echo_label
	 */
	&quot;error_incorrect_user_id&quot;: &quot;(incorrect_user_id) Incorrect user specified in User ID predicate.&quot;,
<span id='Echo-Control-property-error_unknown'>	/**
</span>	 * @echo_label
	 */
	&quot;error_unknown&quot;: &quot;(unknown) Unknown error.&quot;
};

<span id='Echo-Control-method-get'>/**
</span> * Accessor method to get specific field.
 *
 * This function returns the corresponding value of the given key or the default value if specified in the second argument.
 *
 * @param {String} key
 * Defines the key for data extraction.
 *
 * @param {Object} [defaults]
 * Default value if no corresponding key was found in the config. Note: only the 'undefined' JS statement triggers the default value usage. The false, null, 0, [] are considered as a proper value.
 *
 * @return {Mixed}
 * The corresponding value found in the object.
 */
Echo.Control.prototype.get = function(key, defaults) {
	return Echo.Utils.getNestedValue(this, key, defaults);
};

<span id='Echo-Control-method-set'>/**
</span> * Setter method to define specific object value.
 *
 * This function allows to define the value for the corresponding object field.
 *
 * @param {String} key
 * Defines the key where the given data should be stored.
 *
 * @param {Mixed} value
 * The corresponding value which should be defined for the key.
 */
Echo.Control.prototype.set = function(key, value) {
	Echo.Utils.setNestedValue(this, key, value);
};

<span id='Echo-Control-method-remove'>/**
</span> * Method to remove specific object field.
 *
 * This function allows to remove the value associated with the given key.
 * If the key contains a complex structure (such as objects or arrays), it will be removed as well.
 *
 * @param {String} key
 * Specifies the key which should be removed from the object.
 */
Echo.Control.prototype.remove = function(key) {
	this.set(key, undefined);
};

<span id='Echo-Control-method-substitute'>/**
</span> * Templater function which compiles given template using the provided data.
 *
 * Function can be used widely for html templates processing or any other action requiring string interspersion.
 *
 * @param {Object} args
 * Specifies substitution process, contains control parameters.
 *
 * @param {String} args.template
 * Template containing placeholders used for data interspersion.
 *
 * @param {Object} [args.data]
 * Data used in the template compilation.
 *
 * @param {Boolean} [args.strict]
 * Specifies whether the template should be replaced with the corresponding value, preserving replacement value type.
 *
 * @param {Object} [args.instructions]
 * Object containing the list of extra instructions to be applied during template compilation.
 *
 * @return {String}
 * Compiled string value.
 */
Echo.Control.prototype.substitute = function(args) {
	var instructions = $.extend(this._getSubstitutionInstructions(args.data), args.instructions || {});
	var regex = Echo.Utils.regexps.templateSubstitution;
	var template = args.template;

	// checking if we need to execute in a strict mode,
	// i.e. whether to keep the substitution value type or not
	if (args.strict &amp;&amp; (new RegExp(&quot;^&quot; + regex + &quot;$&quot;, &quot;i&quot;)).test(template)) {
		var match = new RegExp(regex, &quot;i&quot;).exec(template);
		if (match &amp;&amp; match[1] &amp;&amp; instructions[match[1]]) {
			return instructions[match[1]](match[2]);
		}
	}

	// perform regular string sustitution
	return template.replace(new RegExp(regex, &quot;ig&quot;), function(match, key, value) {
		if (!instructions[key]) return match;
		var result = instructions[key].call(this, value, &quot;&quot;);
		var allowedTypes = [&quot;number&quot;, &quot;string&quot;, &quot;boolean&quot;];
		return ~$.inArray(typeof result, allowedTypes) ? result : &quot;&quot;;
	});
};

<span id='Echo-Control-method-refresh'>/**
</span> * Basic method to reinitialize control.
 *
 * Function can be overriden by class descendants implying specific logic.
 */
Echo.Control.prototype.refresh = function() {

	// destroy all nested controls, but preserve self
	this.destroy({&quot;self&quot;: false});

	// restore originally defined data
	this.set(&quot;data&quot;, this.config.get(&quot;data&quot;, {}));

	this._init(this._initializers.get(&quot;refresh&quot;));
};

<span id='Echo-Control-method-destroy'>/**
</span> * Unified method to destroy control.
 */
Echo.Control.prototype.destroy = function(config) {
	Echo.Events.publish({
		&quot;topic&quot;: &quot;Echo.Control.onDestroy&quot;,
		&quot;bubble&quot;: false,
		&quot;context&quot;: this.config.get(&quot;context&quot;),
		&quot;data&quot;: $.extend({&quot;producer&quot;: this, &quot;self&quot;: true}, config)
	});
};

<span id='Echo-Control-method-dependent'>/**
</span> * Method checks if control was initialized from another control.
 *
 * return {Boolean}
 */
Echo.Control.prototype.dependent = function() {
	return !!this.config.get(&quot;parent&quot;);
};

<span id='Echo-Control-method-showMessage'>/**
</span> * Renders info message in the target container.
 *
 * @param {Object} data
 * Object containing info message information.
 *
 * @param {String} [data.layout]
 * Specifies the type of message layout. Can be set to &quot;compact&quot; or &quot;full&quot;.
 *
 * @param {HTMLElement} [data.target]
 * Specifies the target container.
 */
Echo.Control.prototype.showMessage = function(data) {
	if (!this.config.get(&quot;infoMessages.enabled&quot;)) return;
	// TODO: check if we need a parameter to hide error, but show loading messages
	//       (if data.type == &quot;error&quot;)
	var layout = data.layout || this.config.get(&quot;infoMessages.layout&quot;);
	this.dom.render({
		&quot;template&quot;: this.templates.message[layout],
		&quot;data&quot;: data,
		&quot;target&quot;: data.target || this.config.get(&quot;target&quot;)
	});
};

<span id='Echo-Control-method-showError'>/**
</span> * Renders error message in the target container.
 *
 * @param {Object} data
 * Object containing error message information.
 *
 * @param {Object} options
 * Object containing display options.
 */
Echo.Control.prototype.showError = function(data, options) {
	var self = this;
	if (typeof options.retryIn === &quot;undefined&quot;) {
		var label = this.labels.get(&quot;error_&quot; + data.errorCode);
		var message = label == &quot;error_&quot; + data.errorCode
			? &quot;(&quot; + data.errorCode + &quot;) &quot; + (data.errorMessage || &quot;&quot;)
			: label;
		this.showMessage({
			&quot;type&quot;: options.critical ? &quot;error&quot; : &quot;loading&quot;,
			&quot;message&quot;: message,
			&quot;target&quot;: options.target
		});
	} else if (!options.retryIn &amp;&amp; options.request.retryTimer) {
		this.showMessage({
			&quot;type&quot;: &quot;loading&quot;,
			&quot;message&quot;: this.labels.get(&quot;retrying&quot;),
			&quot;target&quot;: options.target
		});
	} else {
		var secondsLeft = options.retryIn / 1000;
		var ticker = function() {
			if (!secondsLeft) {
				return;
			}
			var label = self.labels.get(&quot;error_&quot; + data.errorCode, {&quot;seconds&quot;: secondsLeft--});
			self.showMessage({
				&quot;type&quot;: &quot;loading&quot;,
				&quot;message&quot;: label,
				&quot;target&quot;: options.target
			});
		};
		options.request.retryTimer = setInterval(ticker, 1000);
		ticker();
	}
};

<span id='Echo-Control-method-getPlugin'>/**
</span> * Accessor function allowing to obtain the plugin by its name.
 *
 * @param {String} name
 * Specifies plugin name.
 *
 * @return {Object}
 * Instance of the corresponding plugin.
 */
Echo.Control.prototype.getPlugin = function(name) {
	return this.plugins[name];
};

<span id='Echo-Control-method-template'>/**
</span> * Method to get the control template during rendering procedure. Can be overriden.
 */
Echo.Control.prototype.template = function() {
	return this.templates.main;
};

<span id='Echo-Control-method-parentRenderer'>/**
</span> * Method to call parent renderer function, which was extended using Echo.Control.extendRenderer function.
 *
 * @param {String} name
 * Renderer name.
 *
 * @param {Object} args
 * Arguments to be proxied to the parent renderer from the overriden one.
 *
 * @return {HTMLElement}
 * Result of parent renderer function call.
 */
Echo.Control.prototype.parentRenderer = function(name, args) {
	var renderer = this._getRenderer(name);
	if (!renderer || !renderer.next) return args[0]; // return DOM element
	return renderer.next.apply(this, args);
};

<span id='Echo-Control-method-extendTemplate'>/**
</span> * Method to extend the template of particular control.
 *
 * @param {String} action
 * One of the following actions:
 *
 * + &quot;insertBefore&quot;
 * + &quot;insertAfter&quot;
 * + &quot;insertAsFirstChild&quot;
 * + &quot;insertAsLastChild&quot;
 * + &quot;replace&quot;
 * + &quot;remove&quot;
 *
 * @param {String} anchor
 * Element name which is a subject of a transformation application.
 *
 * @param {String} [html]
 * The content of a transformation to be applied. This param is required for all actions except &quot;remove&quot;.
 */
Echo.Control.prototype.extendTemplate = function(action, anchor, html) {
	this.extension.template.push({&quot;action&quot;: action, &quot;anchor&quot;: anchor, &quot;html&quot;: html});
};

/*
 * Method extending the paticular renderer with defined function.
 *
 * @param {String} name
 * Renderer name to be extended.
 *
 * @param {Function} renderer
 * Renderer function to be applied.
 */
Echo.Control.prototype.extendRenderer = function(name, renderer) {
	var renderers = this.extension.renderers;
	renderers[name] = renderers[name] || {&quot;functions&quot;: []};
	renderers[name].functions.unshift(renderer);
};

<span id='Echo-Control-method-log'>/**
</span> * @inheritdoc Echo.Utils#log
 */
Echo.Control.prototype.log = function(data) {
	Echo.Utils.log($.extend(data, {&quot;component&quot;: this.name}));
};

Echo.Control.prototype._init = function(subsystems) {
	var control = this;
	if (!subsystems || !subsystems.length) return;
	var func = subsystems.shift();
	var parts = func.split(&quot;:&quot;);
	var subsystem = {
		&quot;name&quot;: parts[0],
		&quot;init&quot;: control._initializers[parts[0]],
		&quot;type&quot;: parts[1] || &quot;sync&quot;
	};
	if (subsystem.type == &quot;sync&quot;) {
		var result = subsystem.init.call(control);
		if (typeof result != &quot;undefined&quot;) {
			control[subsystem.name] = result;
		}
		control._init(subsystems);
	} else {
		subsystem.init.call(control, function() {
			control._init(subsystems);
		});
	}
};

Echo.Control.prototype._initializers = {};

Echo.Control.prototype._initializers.list = [
	[&quot;vars&quot;,               [&quot;init&quot;, &quot;refresh&quot;]],
	[&quot;extension&quot;,          [&quot;init&quot;, &quot;refresh&quot;]],
	[&quot;config&quot;,             [&quot;init&quot;]],
	[&quot;events&quot;,             [&quot;init&quot;]],
	[&quot;subscriptions&quot;,      [&quot;init&quot;, &quot;refresh&quot;]],
	[&quot;labels&quot;,             [&quot;init&quot;]],
	[&quot;css&quot;,                [&quot;init&quot;]],
	[&quot;renderers&quot;,          [&quot;init&quot;, &quot;refresh&quot;]],
	[&quot;dom&quot;,                [&quot;init&quot;]],
	[&quot;loading&quot;,            [&quot;init&quot;, &quot;refresh&quot;]],
	[&quot;dependencies:async&quot;, [&quot;init&quot;]],
	[&quot;user:async&quot;,         [&quot;init&quot;, &quot;refresh&quot;]],
	[&quot;plugins:async&quot;,      [&quot;init&quot;, &quot;refresh&quot;]],
	[&quot;init:async&quot;,         [&quot;init&quot;, &quot;refresh&quot;]],
	[&quot;ready&quot;,              [&quot;init&quot;]],
	[&quot;refresh&quot;,            [&quot;refresh&quot;]]
];

Echo.Control.prototype._initializers.get = function(action) {
	return Echo.Utils.foldl([], this.list, function(initializer, acc) {
		if (~$.inArray(action, initializer[1])) {
			acc.push(initializer[0]);
		}
	});
};

Echo.Control.prototype._initializers.vars = function() {
	// we need to apply default field values to the control,
	// but we need to avoid any references to the default var objects,
	// thus we copy and recursively merge default values separately
	// and apply default values to the given instance non-recursively
	$.extend(this, $.extend(true, {}, this.defaults.vars, this._manifest(&quot;vars&quot;)));
};

Echo.Control.prototype._initializers.extension = function() {
	return {&quot;renderers&quot;: {}, &quot;template&quot;: []};
};

Echo.Control.prototype._initializers.config = function() {
	var control = this;
	var _normalizer = {};
	var data = this.config;
	_normalizer.target = $;
	_normalizer.plugins = function(list) {
		var data = Echo.Utils.foldl({&quot;hash&quot;: {}, &quot;order&quot;: []}, list || [],
			function(plugin, acc) {
				var pos = $.inArray(plugin.name, acc.order);
				if (pos &gt;= 0) {
					acc.order.splice(pos, 1);
				}
				acc.order.push(plugin.name);
				acc.hash[plugin.name] = plugin;
			});
		this.set(&quot;pluginsOrder&quot;, data.order);
		return data.hash;
	};
	data = $.extend({&quot;plugins&quot;: []}, data || {});
	var defaults = $.extend(true, {}, this.get(&quot;defaults.config&quot;), {
		&quot;context&quot;: (data.parent ? data.parent.context + &quot;/&quot; : &quot;&quot;) + Echo.Utils.getUniqueString()
	}, this._manifest(&quot;config&quot;) || {});
	// TODO: find better home for normalizer...
	var normalizer = this._manifest(&quot;config&quot;).normalizer;
	return new Echo.Configuration(data, defaults, function(key, value) {
		var handler = normalizer &amp;&amp; normalizer[key] || _normalizer &amp;&amp; _normalizer[key];
		return handler ? handler.call(this, value, control) : value;
	});
};

Echo.Control.prototype._initializers.events = function() {
	var control = this;
	var prepare = function(params) {
		params.context = params.context || control.config.get(&quot;context&quot;);
		if (params.handler) {
			params.handler = $.proxy(params.handler, control);
		}
		return params;
	};
	return {
		&quot;publish&quot;: function(params) {
			params.topic = control.name + &quot;.&quot; + params.topic;
			params.data = params.data || {};

			// process data through the normalization function if defined
			if (control._prepareEventParams) {
				params.data = control._prepareEventParams(params.data);
			}

			Echo.Events.publish(prepare(params));
		},
		&quot;subscribe&quot;: function(params) {
			var handlerId = Echo.Events.subscribe(prepare(params));
			control.subscriptionIDs[handlerId] = true;
			return handlerId;
		},
		&quot;unsubscribe&quot;: function(params) {
			if (params &amp;&amp; params.handlerId) {
				delete control.subscriptionIDs[params.handlerId];
			}
			Echo.Events.unsubscribe(prepare(params));
		}
	};
};

Echo.Control.prototype._initializers.subscriptions = function() {
	var control = this;
	$.each(control._manifest(&quot;events&quot;), function(topic, data) {
		data = $.isFunction(data) ? {&quot;handler&quot;: data} : data;
		control.events.subscribe($.extend({&quot;topic&quot;: topic}, data));
	});

	// we need two subscriptions here, because the &quot;Echo.Control.onDataInvalidate&quot; event
	// may be published by the nested controls (in this case the event is not broadcasted
	// to the &quot;global&quot; context) and by the standalone control to notify other controls
	// (not related directly) about the need to invalidate the data (in this case
	// the &quot;global&quot; context is used)
	$.map([&quot;global&quot;, control.config.get(&quot;context&quot;)], function(context) {
		control.events.subscribe({
			&quot;topic&quot;: &quot;Echo.Control.onDataInvalidate&quot;,
			&quot;context&quot;: context,
			&quot;handler&quot;: function() {
				if (control.get(&quot;request&quot;)) {
					control.get(&quot;request&quot;).send({&quot;force&quot;: true});
				}
			}
		});
	});

	// call &quot;ready&quot; callback after the control was rendered
	// note: &quot;ready&quot; callback is executed only once!
	if (control.config.get(&quot;ready&quot;)) {
		control.events.subscribe({
			&quot;topic&quot;: control.name + &quot;.onReady&quot;,
			&quot;once&quot;: true,
			&quot;handler&quot;: function() {
				control.config.get(&quot;ready&quot;).call(control);
			}
		});
	}

	// register destroy handlers
	control.events.subscribe({
		&quot;topic&quot;: &quot;Echo.Control.onDestroy&quot;,
		&quot;once&quot;: true,
		&quot;handler&quot;: function(topic, data) {
			// destroy plugins
			$.map(control.config.get(&quot;pluginsOrder&quot;), function(name) {
				var plugin = control.plugins[name];
				if (plugin &amp;&amp; plugin.destroy) {
					plugin.destroy();
				}
			});

			// apply control-specific logic
			if (control._manifest(&quot;destroy&quot;)) {
				control._manifest(&quot;destroy&quot;).call(control, data.producer);
			}

			// abort and cleanup data request machinery
			var request = control.get(&quot;request&quot;);
			if (request) {
				request.abort();
				control.remove(&quot;request&quot;);
			}

			// unsubscribe from all events when:
			//  - we want to destroy the whole control
			//  - the control is a dependent one
			var ctx = function(obj) { return obj.config.get(&quot;context&quot;); };
			if (data.self || ctx(control) != ctx(data.producer)) {
				$.each(control.subscriptionIDs, function(handlerId) {
					control.events.unsubscribe({&quot;handlerId&quot;: handlerId});
				});
			}

			// cleanup target element for top level control
			if (!control.dependent()) {
				control.config.get(&quot;target&quot;).empty();
			}
		}
	});

	// subscribe all root level controls to the user login/logout event
	// and call the &quot;refresh&quot; control method
	if (!control.dependent()) {
		control.events.subscribe({
			&quot;topic&quot;: &quot;Echo.UserSession.onInvalidate&quot;,
			&quot;context&quot;: &quot;global&quot;,
			&quot;once&quot;: true,
			&quot;handler&quot;: control.refresh
		});
	}
};

Echo.Control.prototype._initializers.labels = function() {
	var labels = $.extend({}, this.get(&quot;defaults.labels&quot;), this._manifest(&quot;labels&quot;));

	// define default language var values with the lowest priority available
	Echo.Labels.set(labels, this.name, true);

	// define language var values passed within the config with the highest priority
	return new Echo.Labels(this.config.get(&quot;labels&quot;), this.name);
};

Echo.Control.prototype._initializers.css = function() {
	Echo.Utils.addCSS(this.baseCSS, &quot;control&quot;);
	this.config.get(&quot;target&quot;).addClass(this.cssClass);
	if (this._manifest(&quot;css&quot;)) {
		Echo.Utils.addCSS(this.substitute({&quot;template&quot;: this._manifest(&quot;css&quot;)}), this.name);
	}
};

Echo.Control.prototype._initializers.renderers = function() {
	var control = this;
	$.each(this._manifest(&quot;renderers&quot;), function() {
		control.extendRenderer.apply(control, arguments);
	});
};

Echo.Control.prototype._initializers.dom = function() {
	var self = this;
	this.dom = {
		// private fields
		&quot;_rendered&quot;: false,
		&quot;_elements&quot;: {},

		// public functions
		&quot;clear&quot;: function() {
			this._elements = {};
		},
		&quot;set&quot;: function(name, element) {
			this._elements[self.cssPrefix + name] = $(element);
		},
		&quot;get&quot;: function(name, ignorePrefix) {
			return this._elements[(ignorePrefix ? &quot;&quot; : self.cssPrefix) + name];
		},
		&quot;remove&quot;: function(element) {
			var name = typeof element === &quot;string&quot;
				? self.cssPrefix + element
				: element.echo.name;
			this._elements[name].remove();
			delete this._elements[name];
		},
		&quot;rendered&quot;: function() {
			return this._rendered;
		},
		&quot;render&quot;: function(args) {

			// render the whole control when no extra config was passed
			if (!args) {
				self.dom.clear();
				var topic = this.rendered() ? &quot;onRerender&quot; : &quot;onRender&quot;;
				var dom = self._render.template.call(self, {
					&quot;template&quot;: self.template,
					&quot;data&quot;: self.data
				});
				self.config.get(&quot;target&quot;).empty().append(dom);
				this._rendered = true;
				self.events.publish({&quot;topic&quot;: topic});
				return dom;
			}

			args = args || {};
			args.data = args.data || self.data;
			args.template = args.template || self.template;

			// render specific element (recursively if specified)
			if (args.name) {
				var processor = args.recursive ? &quot;recursive&quot; : &quot;element&quot;;
				return self._render[processor].call(self, args);
			}

			// render template
			if (args.template) {
				var dom = self._render.template.call(self, args);
				if (args.target) {
					args.target.empty().append(dom);
				}
				return dom;
			}

		}
	};
};

Echo.Control.prototype._initializers.loading = function() {
	this.showMessage({
		&quot;type&quot;: &quot;loading&quot;,
		&quot;message&quot;: this.labels.get(&quot;loading&quot;)
	});
};

Echo.Control.prototype._initializers.dependencies = function(callback) {
	this._loadScripts(this._manifest(&quot;dependencies&quot;), callback);
};

Echo.Control.prototype._initializers.user = function(callback) {
	var control = this;
	if (this.config.get(&quot;user&quot;)) {
		this.user = this.config.get(&quot;user&quot;);
		callback.call(control);
	} else {
		Echo.UserSession({
			&quot;appkey&quot;: this.config.get(&quot;appkey&quot;),
			&quot;ready&quot;: function() {
				control.user = this;
				callback.call(control);
			}
		});
	}
};

Echo.Control.prototype._initializers.plugins = function(callback) {
	var control = this;
	this._loadPluginScripts(function() {
		$.map(control.config.get(&quot;pluginsOrder&quot;), function(name) {
			var plugin = Echo.Plugin.getClass(name, control.name);
			if (plugin) {
				var instance = new plugin({&quot;component&quot;: control});
				if (instance.enabled()) {
					instance.init();
					control.plugins[name] = instance;
				}
			}
		});
		callback.call(control);
	});
};

Echo.Control.prototype._initializers.init = function(callback) {

	// this function should be called inside the &quot;init&quot; function
	// to indicate that the control was initialized and is now ready
	this.ready = callback;

	this._manifest(&quot;init&quot;).call(this);
};

Echo.Control.prototype._initializers.ready = function() {
	this.events.publish({&quot;topic&quot;: &quot;onReady&quot;});
};

Echo.Control.prototype._initializers.refresh = function() {
	this.events.publish({&quot;topic&quot;: &quot;onRefresh&quot;});
};

Echo.Control.prototype._getSubstitutionInstructions = function(data) {
	var control = this;
	return {
		&quot;class&quot;: function(key) {
			return key ? control.cssPrefix + key : control.cssClass
		},
		&quot;data&quot;: function(key, defaults) {
			return Echo.Utils.getNestedValue(data || control.data, key, defaults);
		},
		&quot;label&quot;: function(key, defaults) {
			return control.labels.get(key, defaults);
		},
		&quot;self&quot;: function(key, defaults) {
			var value = Echo.Utils.getNestedValue(control, key);
			value = $.isFunction(value) ? value.call(control) : value;
			return typeof value == &quot;undefined&quot;
				? Echo.Utils.getNestedValue(control.data, key, defaults)
				: value;
		},
		&quot;config&quot;: function(key, defaults) {
			var value = control.config.get(key, defaults);
			return $.isFunction(value) ? value.call(control) : value;
		}
	};
};

Echo.Control.prototype._manifest = function(key) {
	var component = Echo.Utils.getComponent(this.name);
	return component
		? key ? component.manifest[key] : component.manifest
		: undefined;
};

Echo.Control.prototype._loadScripts = function(scripts, callback) {
	var control = this;
	Echo.Loader.download({
		&quot;scripts&quot;: scripts,
		&quot;errorTimeout&quot;: control.config.get(&quot;scriptLoadErrorTimeout&quot;),
		&quot;callback&quot;: function() {
			callback.call(control);
		}
	});
};

Echo.Control.prototype._loadPluginScripts = function(callback) {
	var control = this;
	var plugins = this.config.get(&quot;pluginsOrder&quot;);

	var iterators = {
		&quot;plugins&quot;: function(name, plugin) {
			// check if a script URL is defined for the plugin
			var url = &quot;plugins.&quot; + name + &quot;.url&quot;;
			if (!plugin &amp;&amp; control.config.get(url)) {
				return [{
					&quot;url&quot;: control.config.get(url),
					&quot;loaded&quot;: function() {
						return !!Echo.Plugin.getClass(name, control.name);
					}
				}];
			}
		},
		&quot;dependencies&quot;: function(name, plugin) {
			return plugin &amp;&amp; plugin.dependencies;
		}
	};
	var get = function(type) {
		return Echo.Utils.foldl([], plugins, function(name, acc) {
			var plugin = Echo.Plugin.getClass(name, control.name);
			var scripts = iterators[type](name, plugin);
			if ($.isArray(scripts) &amp;&amp; scripts.length) {
				return acc.concat(scripts);
			}
		});
	};

	control._loadScripts(get(&quot;plugins&quot;), function() {
		control._loadScripts(get(&quot;dependencies&quot;), callback);
	});
};

Echo.Control.prototype._render = {};

Echo.Control.prototype._render.element = function(args) {
	var target = args.target ||
		(args.name &amp;&amp; this.dom.get(args.name)) ||
		this.config.get(&quot;target&quot;);

	if (!this._hasRenderer(args.name)) return target;

	var renderer = this._getRenderer(args.name);
	var iteration = 0;
	renderer.next = function() {
		iteration++;
		return renderer.functions.length &gt; iteration
			? renderer.functions[iteration].apply(this, arguments)
			: target;
	};
	return renderer.functions[iteration].call(this, target, args.extra);
};

Echo.Control.prototype._render.recursive = function(args) {
	var oldNode = this.dom.get(args.name);
	var template = this._compileTemplate(args.template, args.data, this.extension.template);
	template = $(&quot;.&quot; + this.cssPrefix + args.name, $(template));
	this._applyRenderers(template);
	var newNode = this.dom.get(args.name);
	oldNode.replaceWith(newNode);
	return newNode;
};

Echo.Control.prototype._render.template = function(args) {
	var template = this._compileTemplate(args.template, args.data, this.extension.template);
	return this._applyRenderers(template);
};

Echo.Control.prototype._compileTemplate = function(template, data, transformations) {
	var control = this;
	var raw = $.isFunction(template) ? template.call(this) : template;
	var processed = this.substitute({
		&quot;template&quot;: raw,
		&quot;data&quot;: data || {}
	});
	if (transformations &amp;&amp; transformations.length) {
		var dom = $(&quot;&lt;div/&gt;&quot;).html(processed);
		$.map(transformations, function(transformation) {
			dom = control._domTransformer({
				&quot;data&quot;: data || {},
				&quot;dom&quot;: dom,
				&quot;transformation&quot;: transformation
			});
		});
		processed = dom.html();
	}
	return processed;
};

Echo.Control.prototype._applyRenderers = function(template) {
	var self = this;
	var dom = $(template);
	var elements = this._getRenderableElements(dom);
	$.each(elements, function(name, element) {

		// prevent &quot;renderer&quot; function call
		// in case no suitable renderer found
		if (!self._hasRenderer(name)) return;

		self.dom.render({
			&quot;name&quot;: name,
			&quot;target&quot;: element
		});
	});
	return dom;
};

Echo.Control.prototype._domTransformer = function(args) {
	var classify = {
		&quot;insertBefore&quot;: &quot;before&quot;,
		&quot;insertAfter&quot;: &quot;after&quot;,
		&quot;insertAsFirstChild&quot;: &quot;prepend&quot;,
		&quot;insertAsLastChild&quot;: &quot;append&quot;,
		&quot;replace&quot;: &quot;replaceWith&quot;,
		&quot;remove&quot;: &quot;remove&quot;
	};
	var action = classify[args.transformation.action];
	if (!action) {
		return args.dom;
	}
	var content;
	var html = args.transformation.html;
	var anchor = &quot;.&quot; + this.cssPrefix + args.transformation.anchor;
	if (html) {
		content = this.substitute({
			&quot;template&quot;: $.isFunction(html) ? html() : html,
			&quot;data&quot;: args.data
		});
	}
	$(anchor, args.dom)[action](content);
	return args.dom;
};

Echo.Control.prototype._getRenderer = function(name) {
	return this.extension.renderers[name];
};

Echo.Control.prototype._hasRenderer = function(name) {
	return !!this._getRenderer(name);
};

Echo.Control.prototype._getRenderableElements = function(container) {
	var self = this, elements = {};
	var isRenderer = new RegExp(this.cssPrefix + &quot;(.*)$&quot;);
	container.find(&quot;*&quot;).andSelf().each(function(i, element) {
		if (!element.className) {
			return;
		}
		var classes = element.className.split(/[ ]+/);
		$.each(classes, function(j, className) {
			var pattern = className.match(isRenderer);
			var name = pattern ? pattern[1] : undefined;
			if (name) {
				self.dom.set(name, element);
				element = $(element);
				element.echo = element.echo || {};
				element.echo.name = className;
				elements[name] = element;
			}
		});
	});
	return elements;
};

Echo.Control.prototype.baseCSS =
	'.echo-primaryBackgroundColor {  }' +
	'.echo-secondaryBackgroundColor { background-color: #F4F4F4; }' +
	'.echo-trinaryBackgroundColor { background-color: #ECEFF5; }' +
	'.echo-primaryColor { color: #3A3A3A; }' +
	'.echo-secondaryColor { color: #C6C6C6; }' +
	'.echo-primaryFont { font-family: Arial, sans-serif; font-size: 12px; font-weight: normal; line-height: 16px; }' +
	'.echo-secondaryFont { font-family: Arial, sans-serif; font-size: 11px; }' +
	'.echo-linkColor, .echo-linkColor a { color: #476CB8; }' +
	'.echo-clickable { cursor: pointer; }' +
	'.echo-relative { position: relative; }' +
	'.echo-clear { clear: both; }' +

	// message classes
	'.echo-control-message { padding: 15px 0px; text-align: center; }' +
	'.echo-control-message-icon { height: 16px; padding-left: 16px; background: no-repeat left center; }' +
	'.echo-control-message .echo-control-message-icon { padding-left: 21px; height: auto; }' +
	'.echo-control-message-empty { background-image: url(' + Echo.Loader.getURL(&quot;sdk/images/information.png&quot;) + '); }' +
	'.echo-control-message-loading { background-image: url(' + Echo.Loader.getURL(&quot;sdk/images/loading.gif&quot;) + '); }' +
	'.echo-control-message-error { background-image: url(' + Echo.Loader.getURL(&quot;sdk/images/warning.gif&quot;) + '); }';
</pre>
</body>
</html>
