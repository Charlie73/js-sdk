<!DOCTYPE html>
<html>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <title>The source code</title>
  <link href="../resources/prettify/prettify.css" type="text/css" rel="stylesheet" />
  <script type="text/javascript" src="../resources/prettify/prettify.js"></script>
  <style type="text/css">
    .highlight { display: block; background-color: #ddd; }
  </style>
  <script type="text/javascript">
    function highlight() {
      document.getElementById(location.hash.replace(/#/, "")).className = "highlight";
    }
  </script>
</head>
<body onload="prettyPrint(); highlight();">
  <pre class="prettyprint lang-js">(function() {
&quot;use strict&quot;;

if (!window.Echo) window.Echo = {};

if (Echo.Loader) return;

<span id='Echo-Loader'>/**
</span> * @class Echo.Loader
 * Static class which implements common mechanics for canvases loading.
 */
Echo.Loader = {
<span id='Echo-Loader-property-version'>	&quot;version&quot;: &quot;&quot;,
</span><span id='Echo-Loader-property-debug'>	&quot;debug&quot;: false,
</span><span id='Echo-Loader-property-config'>	&quot;config&quot;: {
</span>		&quot;cdnBaseURL&quot;: &quot;http://cdn.echoenabled.com/&quot;,
		&quot;errorTimeout&quot;: 5000 // 5 sec
	},
<span id='Echo-Loader-property-overrides'>	&quot;overrides&quot;: {},
</span><span id='Echo-Loader-property-vars'>	&quot;vars&quot;: {
</span>		&quot;state&quot;: {&quot;resources&quot;: {}, &quot;queue&quot;: []}
	}
};

<span id='Echo-Loader-static-method-getURL'>/**
</span> * @static
 * Function to get normalized URL.
 *
 * @param {String} url
 * JavaScript or CSS stylesheet file URL.
 *
 * @param {Boolean} [devVersion=true]
 * Specifies whether function should return dev version of the file or not,
 * &lt;em&gt;false&lt;/em&gt; value is useful when we want to get URL to image because
 * images don't have dev versions
 */
Echo.Loader.getURL = function(url, devVersion) {
	if (typeof devVersion === &quot;undefined&quot;) devVersion = true;
	return /^https?:\/\/|^\/\//.test(url)
		? url
		: Echo.Loader.config.cdnBaseURL + &quot;sdk/v&quot; + Echo.Loader.version +
			(devVersion &amp;&amp; Echo.Loader.isDebug() ? &quot;/dev&quot; : &quot;&quot;) +
			(!url || url.charAt(0) === &quot;/&quot; ? &quot;&quot; : &quot;/&quot;) + url;
};
<span id='Echo-Loader-static-method-init'>/**
</span> * @static
 * Function to initialize canvases on the page.
 *
 * @param {Object} [config]
 * Object which defines the initialization of config parameters
 *
 * @param {Mixed} [config.canvases]
 * Array of jQuery elements or a single jQuery element, which represents a
 * canvas target. If this param is omitted, Echo Loader will look for the
 * canvases in the DOM structure.
 *
 * @param {Object} [config.target]
 * Target element where Echo Loader should look for the canvases if no
 * canvases were passed in the &quot;config.canvases&quot; field.
 */
Echo.Loader.init = function(config) {
	config = config || {};
	Echo.Loader.initEnvironment(function() {
		var canvases = config.canvases;

		// convert a single canvas to the 1-element array
		// to keep the same contract below in the code
		if (canvases &amp;&amp; !Echo.jQuery.isArray(canvases) &amp;&amp;
			!(canvases instanceof Echo.jQuery)) {
				canvases = [canvases];
		}

		// if no canvases defined during initialization,
		// we look for all canvases in the target ('document' by default)
		canvases = canvases || Echo.jQuery(&quot;.echo-canvas&quot;, config.target);

		Echo.Loader._initCanvases(canvases);
	});
};

<span id='Echo-Loader-static-method-download'>/**
</span> * @static
 * Function to load the JavaScript or CSS stylesheet files in async mode.
 *
 * @param {Array} resources
 * Array of objects with the properties described below:
 *
 * @param {String} resources.url
 * JavaScript or CSS stylesheet file URL.
 *
 * @param {Function} resources.loaded
 * Function used to check whether the script was loaded. This function must return
 * the boolean value which indicates whether the resource was already loaded on the
 * page or not. If the resource has already been loaded - no download is performed
 * and the callback is called immediately.
 *
 * @param {Function} [callback]
 * Callback function which should be called as soon as all requested files
 * were downloaded.
 *
 * @param {Object} [config]
 * Object with configuration parameters
 *
 * @param {Number} config.errorTimeout
 * Timeout loading of resources in milliseconds, use as yepnope.errorTimeout
 *
 */
Echo.Loader.download = function(resources, callback, config) {
	config = config || {};
	callback = callback || function() {};

	if (!resources || !resources.length) {
		callback();
		return;
	}

	var state = Echo.Loader.vars.state;
	var invokeCallbacks = function() {
		var callbacks = [];
		// Important note: we should *not* execute callbacks
		// while iterating through the queue. We need to update
		// the queue first and only after that execute the callbacks,
		// because there might be calls to &quot;Echo.Loader.download&quot; function
		// which can interfere with the current queue state.
		state.queue = Echo.Loader._map(state.queue, function(item) {
			if (Echo.Loader._areResourcesReady(item.resources)) {
				callbacks.push(item.callback);
				return; // do *not* put this resource back into the queue
			}
			return item;
		});
		Echo.Loader._map(callbacks, function(_callback) { _callback(); });
	};

	state.queue.push({&quot;resources&quot;: resources, &quot;callback&quot;: callback});

	var urls = Echo.Loader._map(resources, function(resource) {
		var url = Echo.Loader.getURL(resource.url);
		if (!Echo.Loader._areResourcesReady([resource]) &amp;&amp;
			state.resources[url] !== &quot;loading&quot;) {
				state.resources[url] = &quot;loading&quot;;
				return url;
		}
	});

	// invoke queued handler in case all requested resources
	// are ready by the time the &quot;download&quot; function is called
	if (!urls.length) {
		invokeCallbacks();
		return;
	}

	var prefix = &quot;timeout=&quot; + (config.errorTimeout || Echo.Loader.config.errorTimeout) + &quot;!&quot;;
	Echo.yepnope({
		&quot;load&quot;: Echo.Loader._map(urls, function(url) { return prefix + url; }),
		&quot;complete&quot;: function() {
			// mark all loaded scripts as &quot;ready&quot;
			Echo.Loader._map(urls, function(url) {
				state.resources[url] = &quot;ready&quot;;
			});
			invokeCallbacks();
		}
	});
};

<span id='Echo-Loader-static-method-override'>/**
</span> * @static
 * Function which provides an ability to override config parameters of the
 * specific application within the canvas.
 *
 * @param {String} canvasID
 * Canvas ID.
 *
 * @param {String} appID
 * Application ID inside the canvas.
 *
 * @param {Object} config
 * Object with the application config overrides.
 */
Echo.Loader.override = function(canvasID, appID, config) {
	var overrides = Echo.Loader.overrides;
	overrides[canvasID] = overrides[canvasID] || {};
	overrides[canvasID][appID] = config;
};

<span id='Echo-Loader-static-method-isDebug'>/**
</span> * @static
 * Allows to identify if the debug mode is enabled for Echo environment
 * on the page (i.e whether the logs should be printed in console,
 * non-minified versions of scripts should be used)
 *
 * @return {Boolean}
 */
Echo.Loader.isDebug = function() {
	return Echo.Loader.debug;
};

(function() {
	if (Echo.Loader.debug) return;

	var debug;
	var _debugCookieName = &quot;echo-debug&quot;;
	var options = {&quot;path&quot;: &quot;/&quot;};
	var hashParts = window.location.hash.match(/echo.debug:(true|false)/);
	if (hashParts &amp;&amp; hashParts.length) {
		debug = hashParts[1];
	}
	if (typeof debug !== &quot;undefined&quot;) {
		if (debug === &quot;true&quot;) {
			Echo.Loader.debug = true;
			Echo.Cookie.set(_debugCookieName, true, options);
		} else {
			Echo.Loader.debug = false;
			Echo.Cookie.remove(_debugCookieName, options);
		}
		return;
	}
	Echo.Loader.debug = !!Echo.Cookie.get(_debugCookieName);
})();

<span id='Echo-Loader-static-method-initApplication'>/**
</span> * @static
 * Function to initialize application on the page. The function performs the following actions:
 *
 * + initializes Echo JavaScript environment (if it was not initialized yet)
 * + establishes the Backplane connection (if app.backplane is defined)
 * + establishes Echo User session on the page (if app.config.appkey is defined)
 * + downloads the application script
 * + calls the app JavaScript class constructor which handles further application initialization
 *
 * @param {Object} app
 * Object which defines the base app configuration.
 *
 * @param {String} app.component
 * The name of the JavaScript app class which should be initialized.
 *
 * @param {String} app.script
 * Appliction JavaScript class script URL.
 *
 * @param {Object} [app.scripts]
 * Object which specifies the location (URL) of the production (minified) and development
 * (non-minified) versions of the app JavaScript class code. The &quot;prod&quot; and &quot;dev&quot; keys
 * should be used in order to specify the production and development URLs respectively.
 *
 * @param {Object} [app.backplane]
 * Object which contains the data to be passed into the Backplane.init call.
 *
 * @param {Object} [app.config]
 * Parameters to be passed into the application constructor during its initialization.
 */
Echo.Loader.initApplication = function(app) {
	app = app || {};
	app.config = app.config || {};
	var script = Echo.Loader._getAppScriptURL(app);

	if (!script || !app.component) {
		Echo.Loader._error({
			&quot;args&quot;: {&quot;app&quot;: app},
			&quot;code&quot;: &quot;invalid_app_config&quot;,
			&quot;message&quot;: &quot;Invalid config passed into the initApplication function&quot;
		});
		return;
	}

	var initUser = function(callback) {
		if (!app.config.appkey) {
			callback();
			return;
		}
		Echo.Loader._initUser(app.config, function() { callback &amp;&amp; callback(this); });
	};
	Echo.Loader.initEnvironment(function() {
		Echo.Loader._initBackplane(app.backplane, function() {
			initUser(function(user) {
				Echo.Loader.download([{
					&quot;url&quot;: script,
					&quot;loaded&quot;: function() {
						return Echo.Control.isDefined(app.component);
					}
				}], function() {
					var Application = Echo.Utils.getComponent(app.component);
					if (!Application) {
						Echo.Loader._error({
							&quot;args&quot;: {&quot;app&quot;: app},
							&quot;code&quot;: &quot;no_suitable_app_class&quot;,
							&quot;message&quot;: &quot;Unable to init an app, &quot; +
									&quot;no suitable class found&quot;
						});
						return;
					}
					app.config.user = user;
					new Application(app.config);
				}, {&quot;errorTimeout&quot;: Echo.Loader.config.errorTimeout});
			});
		});
	});
};

<span id='Echo-Loader-static-method-initEnvironment'>/**
</span> * @static
 * Function to initialize Echo environment on the page by downloading Backplane lib,
 * jQuery library with the necessary dependencies and the base Echo classes.
 *
 * @param {Function} [callback]
 * Callback function which should be called as soon as Echo environment is ready.
 */
Echo.Loader.initEnvironment = function(callback) {
	var resources = [{
		&quot;url&quot;: &quot;backplane.js&quot;,
		&quot;loaded&quot;: function() { return !!window.Backplane; }
	}, {
		&quot;url&quot;: &quot;third-party/jquery.pack.js&quot;,
		&quot;loaded&quot;: function() { return !!Echo.jQuery; }
	}, {
		&quot;url&quot;: &quot;environment.pack.js&quot;,
		&quot;loaded&quot;: function() { return !!Echo.Utils; }
	}];
	if (Echo.Loader._areResourcesReady(resources)) {
		callback &amp;&amp; callback();
		return;
	}
	Echo.Loader.download(resources, callback);
};

// implementation of the &quot;map&quot; function for the cases when jQuery is not loaded yet
Echo.Loader._map = function(list, iterator) {
	var result = [];
	if (list &amp;&amp; list.length &amp;&amp; iterator) {
		for (var i = 0; i &lt; list.length; i++) {
			var value = iterator(list[i], i);
			if (value === false) break; // jQuery-like convention
			if (typeof value !== &quot;undefined&quot;) result.push(value);
		}
	}
	return result;
};

Echo.Loader._areResourcesReady = function(resources) {
	var state = Echo.Loader.vars.state;
	var resourceReadyFlags = Echo.Loader._map(resources, function(resource) {
		var url = Echo.Loader.getURL(resource.url);
		// the 'true' flag will be added into the
		// result array only when resource is ready
		return (resource.loaded &amp;&amp; resource.loaded()) ||
			(state.resources[url] &amp;&amp; state.resources[url] === &quot;ready&quot;);
	});
	return resources.length === resourceReadyFlags.length;
};

Echo.Loader._initCanvases = function(canvases) {
	var collection = [];
	Echo.jQuery.map(canvases, function(target) {
		target = Echo.jQuery(target);

		// check if the canvas was already initialized
		if (target.data(&quot;initialized&quot;)) {
			Echo.Loader._error({
				&quot;args&quot;: {&quot;target&quot;: target},
				&quot;code&quot;: &quot;canvas_already_initialized&quot;,
				&quot;message&quot;: &quot;Canvas has been initialized already&quot;
			});
			return;
		}

		var id = target.data(&quot;canvas-id&quot;);
		var appkey = target.data(&quot;appkey&quot;);

		if (!id || !appkey) {
			Echo.Loader._error({
				&quot;args&quot;: {&quot;target&quot;: target},
				&quot;code&quot;: &quot;invalid_canvas_config&quot;,
				&quot;message&quot;: &quot;Canvas with invalid configuration found&quot;
			});
			return;
		}

		// define initialized state for the canvas
		// to prevent multiple initalization of the same canvas
		target.data(&quot;initialized&quot;, true);

		collection.push({&quot;id&quot;: id, &quot;appkey&quot;: appkey, &quot;target&quot;: target});
	});

	if (!collection.length) {
		Echo.Loader._error({
			&quot;code&quot;: &quot;no_canvases_found&quot;,
			&quot;message&quot;: &quot;No canvases found on the page...&quot;
		});
		return;
	}

	Echo.Loader._fetchCanvasConfigs(collection, function(configs) {
		Echo.jQuery.each(collection, function(id, canvas) {
			var config = configs[canvas.id];
			if (!config) return;

			// copy config object to prevent the same object
			// sharing across multiple canvas instances
			canvas.config = Echo.jQuery.extend(true, {}, configs[canvas.id]);

			Echo.Loader._initCanvas(canvas);
		});
	});
};

Echo.Loader._initCanvas = function(canvas) {
	if (!canvas.config.apps || !canvas.config.apps.length) {
		Echo.Loader._error({
			&quot;args&quot;: {&quot;canvas&quot;: canvas},
			&quot;code&quot;: &quot;canvas_with_no_apps&quot;,
			&quot;message&quot;: &quot;Canvas with no applications&quot;
		});
		return;
	}
	Echo.Loader._initBackplane(canvas.config.backplane, function() {
		Echo.Loader._initUser(canvas, function() {
			canvas.config.user = this;
			Echo.Loader._initApplications(canvas);
		});
	});
};

Echo.Loader._initBackplane = function(config, callback) {
	// note: Backplane.init in v2 will be async,
	//       so we need a callback to execute after Backplane init
	callback = callback || function(){};
	if (!config) {
		callback();
		return;
	}
	Backplane.init(config);
	callback();
};

Echo.Loader._initUser = function(canvas, callback) {
	Echo.UserSession({
		&quot;appkey&quot;: canvas.appkey,
		&quot;ready&quot;: callback
	});
};

Echo.Loader._initApplications = function(canvas) {
	var resources = [];
	Echo.jQuery.each(canvas.config.apps, function(id, app) {
		var script = Echo.Loader._getAppScriptURL(app);
		if (!app.component || !script || !app.id) {
			Echo.Loader._error({
				&quot;args&quot;: {&quot;app&quot;: app},
				&quot;code&quot;: &quot;incomplete_app_config&quot;,
				&quot;message&quot;: &quot;Unable to init an app, config is incomplete&quot;
			});
			return;
		}

		app.config = app.config || {};
		app.config.user = canvas.config.user;
		app.config.target = Echo.Loader._createApplicationTarget(app);
		resources.push({
			&quot;url&quot;: script,
			&quot;loaded&quot;: function() {
				return Echo.Utils.isComponentDefined(app.component);
			}
		});
	});

	Echo.Loader.download(resources, function() {
		Echo.jQuery.each(canvas.config.apps, function(id, app) {
			var Application = Echo.Utils.getComponent(app.component);
			if (!Application) {
				Echo.Loader._error({
					&quot;args&quot;: {&quot;app&quot;: app},
					&quot;code&quot;: &quot;no_suitable_app_class&quot;,
					&quot;message&quot;: &quot;Unable to init an app, no suitable class found&quot;
				});
				return;
			}
			var overrides = (Echo.Loader.overrides[canvas.id] || {})[app.id] || {};
			var config = Echo.jQuery.extend(true, app.config, overrides);
			app.ref = new Application(config);
			canvas.target.append(app.config.target);
		});
	}, {
		&quot;errorTimeout&quot;: Echo.Loader.config.errorTimeout
	});
};

Echo.Loader._getAppScriptURL = function(config) {
	return config.scripts &amp;&amp; config.scripts.dev &amp;&amp; config.scripts.prod
		? config.scripts[Echo.Loader.isDebug() ? &quot;dev&quot; : &quot;prod&quot;]
		: config.script;
};

Echo.Loader._createApplicationTarget = function(config) {
	// TODO: add more specific classname and may be id from canvas?
	return Echo.jQuery('&lt;div class=&quot;echo-application&quot;&gt;&lt;/div&gt;');
};

Echo.Loader._fetchCanvasConfigs = function(canvases, callback) {
	if (!canvases.length) return callback();
	var processed = {};
	var requests = Echo.Utils.foldl([], canvases, function(canvas, acc) {

		// do not request config twice
		if (processed[canvas.id]) return;

		processed[canvas.id] = true;
		acc.push({
			&quot;id&quot;: canvas.id,
			&quot;key&quot;: canvas.id,
			&quot;public&quot;: true,
			&quot;method&quot;: &quot;kvs/get&quot;
		});
	});
	Echo.jQuery.get(&quot;http://api.echoenabled.com/v1/mux&quot;, {
		&quot;appkey&quot;: canvases[0].appkey,
		&quot;requests&quot;: Echo.Utils.objectToJSON(requests)
	}, function(response) {
		if (!response || response.result === &quot;error&quot;) {
			Echo.Loader._error({
				&quot;args&quot;: response,
				&quot;code&quot;: &quot;unable_to_retrieve_app_config&quot;,
				&quot;message&quot;: &quot;Unable to retrieve Canvas configs from AppServer&quot;
			});
			return;
		}
		var configs = Echo.Utils.foldl({}, response, function(data, acc, id) {
			if (!data || data.result === &quot;error&quot;) {
				Echo.Loader._error({
					&quot;args&quot;: data,
					&quot;code&quot;: &quot;unable_to_retrieve_app_config&quot;,
					&quot;message&quot;: &quot;Unable to retrieve Canvas config from AppServer&quot;
				});
				return;
			}
			var config;
			try {
				config = Echo.jQuery.parseJSON(data.value);
			} catch(exception) {
				Echo.Loader._error({
					&quot;args&quot;: [data, exception],
					&quot;code&quot;: &quot;unable_to_parse_app_config&quot;,
					&quot;message&quot;: &quot;Unable to parse JSON config&quot;
				});
			}
			if (config) {
				acc[id] = config;
			}
		});
		callback(configs);
	}, &quot;jsonp&quot;);
};

Echo.Loader._error = function(data) {
	Echo.Events.publish({
		&quot;topic&quot;: &quot;Echo.Loader.onError&quot;,
		&quot;data&quot;: data
	});
	Echo.Utils.log(Echo.jQuery.extend(data, {&quot;type&quot;: &quot;error&quot;, &quot;component&quot;: &quot;Echo.Loader&quot;}));
};

})();
</pre>
</body>
</html>
